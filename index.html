<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Runner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #fff;
        }

        #gameContainer {
            text-align: center;
        }

        #startScreen, #gameScreen {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        #startScreen {
            display: block;
        }

        #gameScreen {
            display: none;
        }

        h1 {
            font-size: 3em;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        }

        .info {
            font-size: 1.2em;
            margin: 15px 0;
            color: #aaa;
        }

        .level-info {
            font-size: 1.5em;
            color: #00ff88;
            margin: 10px 0;
        }

        button {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            border: none;
            color: #1a1a2e;
            font-size: 1.5em;
            padding: 15px 50px;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 30px;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(0, 255, 136, 0.6);
        }

        button:active {
            transform: translateY(-1px);
        }

        #canvas {
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.2);
            display: block;
            margin: 20px auto;
        }

        #gameInfo {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            font-size: 1.2em;
        }

        .stat {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .description {
            max-width: 600px;
            margin: 20px auto;
            line-height: 1.6;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="startScreen">
            <h1>ðŸŽ® MAZE RUNNER</h1>
            <p class="description">
                Navigate through the darkness using only your memory. 
                Walls fade after time - remember the path before it's too late!
            </p>
            <div class="level-info">Level: <span id="currentLevel">1</span></div>
            <div class="info">Grid Size: <span id="gridSize">3Ã—3</span></div>
            <div class="info">Use Arrow Keys or WASD to move</div>
            <button id="startBtn">START GAME</button>
        </div>

        <div id="gameScreen">
            <h1>MAZE RUNNER</h1>
            <canvas id="canvas" width="600" height="600"></canvas>
            <div id="gameInfo">
                <div class="stat">Level: <span id="levelDisplay">1</span></div>
                <div class="stat">Grid: <span id="gridDisplay">5Ã—5</span></div>
                <div class="stat">Moves: <span id="moveCount">0</span></div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let level = 1;
        let gridSize = 3;
        let cellSize;
        let player;
        let maze;
        let exit;
        let moves = 0;
        let visibleCells = new Set();
        let cellMemory = {}; // Stores when cells were last seen
        const MEMORY_DURATION = 0; // Walls disappear immediately when you leave
        const FADE_DURATION = 0; // No fade, instant disappear
        const VISIBILITY_RADIUS = 1.2; // Much smaller visibility - just current cell and slight peek

        // Level progression: [gridSize, numberOfLevelsAtThisSize]
        const LEVEL_PROGRESSION = [
            { grid: 3, levels: 1 },   // Levels 1-2: 3Ã—3
            { grid: 4, levels: 1 },   // Levels 3-5: 4Ã—4
            { grid: 5, levels: 1 },   // Levels 6-8: 5Ã—5
            { grid: 6, levels: 2 },   // Levels 9-11: 6Ã—6
            { grid: 7, levels: 2 },   // Levels 12-15: 7Ã—7
            { grid: 8, levels: 2 },   // Levels 16-19: 8Ã—8
            { grid: 9, levels:  2},   // Levels 20-23: 9Ã—9
            { grid: 10, levels: 3 },  // Levels 24-28: 10Ã—10
            { grid: 11, levels: 3 },  // And so on...
            { grid: 12, levels: 3 },
            { grid: 13, levels: 3 },
            { grid: 14, levels: 4 },
            { grid: 15, levels: 4 },
            { grid: 16, levels: 4 },
            { grid: 17, levels: 4 },
            { grid: 18, levels: 4 },
            { grid: 19, levels: 4 },
            { grid: 20, levels: 4 },
            { grid: 21, levels: 4 },
            { grid: 22, levels: 4 },
            { grid: 23, levels: 4 },
            { grid: 24, levels: 4 },
            { grid: 25, levels: 4 },
            { grid: 26, levels: 4 },
            { grid: 27, levels: 4 },
            { grid: 28, levels: 4 },
            { grid: 29, levels: 4 },
            { grid: 30, levels: 4 }
        ];

        function hasLineOfSight(fromX, fromY, toX, toY) {
            // Check if there's a clear path between two cells (no walls blocking)
            if (fromX === toX && fromY === toY) return true;
            
            // Check horizontal line of sight
            if (fromY === toY) {
                const minX = Math.min(fromX, toX);
                const maxX = Math.max(fromX, toX);
                
                for (let x = minX; x < maxX; x++) {
                    if (maze[fromY][x].walls.right) return false;
                }
                return true;
            }
            
            // Check vertical line of sight
            if (fromX === toX) {
                const minY = Math.min(fromY, toY);
                const maxY = Math.max(fromY, toY);
                
                for (let y = minY; y < maxY; y++) {
                    if (maze[y][fromX].walls.bottom) return false;
                }
                return true;
            }
            
            // Not in straight line - no line of sight
            return false;
        }

        function getGridSizeForLevel(lvl) {
            let cumulativeLevels = 0;
            for (let prog of LEVEL_PROGRESSION) {
                if (lvl <= cumulativeLevels + prog.levels) {
                    return prog.grid;
                }
                cumulativeLevels += prog.levels;
            }
            return 15; // Max grid size
        }

        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.walls = { top: true, right: true, bottom: true, left: true };
                this.visited = false;
            }
        }

        function initGame() {
            gridSize = getGridSizeForLevel(level);
            
            cellSize = canvas.width / gridSize;
            moves = 0;
            visibleCells.clear();
            cellMemory = {};
            
            updateDisplay();
            generateMaze();
            
            // Always start at top-left corner
            player = { x: 0, y: 0 };
            
            // Randomly pick one of the other 3 corners for exit
            const corners = [
                { x: gridSize - 1, y: 0 },           // Top-right
                { x: 0, y: gridSize - 1 },           // Bottom-left
                { x: gridSize - 1, y: gridSize - 1 } // Bottom-right
            ];
            exit = corners[Math.floor(Math.random() * corners.length)];
            
            updateVisibility();
            gameLoop();
        }

        function generateMaze() {
            maze = [];
            for (let y = 0; y < gridSize; y++) {
                maze[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    maze[y][x] = new Cell(x, y);
                }
            }

            // Recursive backtracking algorithm
            const stack = [];
            const start = maze[0][0];
            start.visited = true;
            stack.push(start);

            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = getUnvisitedNeighbors(current);

                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    removeWall(current, next);
                    next.visited = true;
                    stack.push(next);
                } else {
                    stack.pop();
                }
            }
        }

        function getUnvisitedNeighbors(cell) {
            const neighbors = [];
            const { x, y } = cell;

            if (y > 0 && !maze[y - 1][x].visited) neighbors.push(maze[y - 1][x]);
            if (x < gridSize - 1 && !maze[y][x + 1].visited) neighbors.push(maze[y][x + 1]);
            if (y < gridSize - 1 && !maze[y + 1][x].visited) neighbors.push(maze[y + 1][x]);
            if (x > 0 && !maze[y][x - 1].visited) neighbors.push(maze[y][x - 1]);

            return neighbors;
        }

        function removeWall(current, next) {
            const dx = next.x - current.x;
            const dy = next.y - current.y;

            if (dx === 1) {
                current.walls.right = false;
                next.walls.left = false;
            } else if (dx === -1) {
                current.walls.left = false;
                next.walls.right = false;
            } else if (dy === 1) {
                current.walls.bottom = false;
                next.walls.top = false;
            } else if (dy === -1) {
                current.walls.top = false;
                next.walls.bottom = false;
            }
        }

        function updateVisibility() {
            const currentTime = Date.now();
            
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt(
                        Math.pow(x - player.x, 2) + 
                        Math.pow(y - player.y, 2)
                    );
                    
                    if (dist <= VISIBILITY_RADIUS) {
                        const key = `${x},${y}`;
                        visibleCells.add(key);
                        cellMemory[key] = currentTime;
                    }
                }
            }
        }

        function getCellOpacity(x, y, currentTime) {
            // Only show cells currently in visibility range
            const dist = Math.sqrt(
                Math.pow(x - player.x, 2) + 
                Math.pow(y - player.y, 2)
            );
            
            if (dist <= VISIBILITY_RADIUS) {
                return 1.0;
            }
            
            // Everything else is hidden - true memory game!
            return 0;
        }

        function draw() {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const currentTime = Date.now();

            // Draw maze walls with memory fading
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const cell = maze[y][x];
                    const opacity = getCellOpacity(x, y, currentTime);
                    
                    if (opacity > 0) {
                        ctx.strokeStyle = `rgba(100, 100, 150, ${opacity})`;
                        ctx.lineWidth = 2;

                        const px = x * cellSize;
                        const py = y * cellSize;

                        ctx.beginPath();
                        if (cell.walls.top) {
                            ctx.moveTo(px, py);
                            ctx.lineTo(px + cellSize, py);
                        }
                        if (cell.walls.right) {
                            ctx.moveTo(px + cellSize, py);
                            ctx.lineTo(px + cellSize, py + cellSize);
                        }
                        if (cell.walls.bottom) {
                            ctx.moveTo(px, py + cellSize);
                            ctx.lineTo(px + cellSize, py + cellSize);
                        }
                        if (cell.walls.left) {
                            ctx.moveTo(px, py);
                            ctx.lineTo(px, py + cellSize);
                        }
                        ctx.stroke();
                    }
                }
            }

            // Draw exit - visible ONLY if within range AND no walls blocking (line of sight)
            const exitDist = Math.sqrt(
                Math.pow(exit.x - player.x, 2) + 
                Math.pow(exit.y - player.y, 2)
            );
            
            if (exitDist <= VISIBILITY_RADIUS && hasLineOfSight(player.x, player.y, exit.x, exit.y)) {
                // Exit is visible - clear line of sight like seeing light in a cave!
                ctx.fillStyle = 'rgba(255, 100, 100, 0.9)';
                ctx.shadowColor = 'rgba(255, 100, 100, 0.6)';
                ctx.shadowBlur = 15;
                ctx.fillRect(
                    exit.x * cellSize + cellSize * 0.2,
                    exit.y * cellSize + cellSize * 0.2,
                    cellSize * 0.6,
                    cellSize * 0.6
                );
                ctx.shadowBlur = 0;
            }

            // Draw visibility radius (subtle green glow)
            const gradient = ctx.createRadialGradient(
                player.x * cellSize + cellSize / 2,
                player.y * cellSize + cellSize / 2,
                0,
                player.x * cellSize + cellSize / 2,
                player.y * cellSize + cellSize / 2,
                VISIBILITY_RADIUS * cellSize
            );
            gradient.addColorStop(0, 'rgba(0, 255, 136, 0.15)');
            gradient.addColorStop(0.5, 'rgba(0, 255, 136, 0.05)');
            gradient.addColorStop(1, 'rgba(0, 255, 136, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw player
            ctx.fillStyle = '#00ff88';
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(
                player.x * cellSize + cellSize / 2,
                player.y * cellSize + cellSize / 2,
                cellSize * 0.3,
                0,
                Math.PI * 2
            );
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function gameLoop() {
            draw();
            requestAnimationFrame(gameLoop);
        }

        function movePlayer(dx, dy) {
            const newX = player.x + dx;
            const newY = player.y + dy;

            if (newX < 0 || newX >= gridSize || newY < 0 || newY >= gridSize) return;

            const cell = maze[player.y][player.x];
            
            if (dx === 1 && cell.walls.right) return;
            if (dx === -1 && cell.walls.left) return;
            if (dy === 1 && cell.walls.bottom) return;
            if (dy === -1 && cell.walls.top) return;

            player.x = newX;
            player.y = newY;
            moves++;
            document.getElementById('moveCount').textContent = moves;

            updateVisibility();

            if (player.x === exit.x && player.y === exit.y) {
                setTimeout(() => {
                    level++;
                    showStartScreen();
                }, 300);
            }
        }

        function updateDisplay() {
            document.getElementById('levelDisplay').textContent = level;
            document.getElementById('gridDisplay').textContent = `${gridSize}Ã—${gridSize}`;
            document.getElementById('moveCount').textContent = moves;
        }

        function showStartScreen() {
            document.getElementById('currentLevel').textContent = level;
            const nextGridSize = getGridSizeForLevel(level);
            document.getElementById('gridSize').textContent = `${nextGridSize}Ã—${nextGridSize}`;
            document.getElementById('startScreen').style.display = 'block';
            document.getElementById('gameScreen').style.display = 'none';
        }

        function showGameScreen() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            showGameScreen();
            initGame();
        });

        document.addEventListener('keydown', (e) => {
            if (document.getElementById('gameScreen').style.display === 'none') return;

            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    e.preventDefault();
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    e.preventDefault();
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    e.preventDefault();
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    e.preventDefault();
                    movePlayer(1, 0);
                    break;
            }
        });
    </script>
</body>
</html>